<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Points-of-Sail Simulator</title>
<style>
  html,body{margin:0;height:100%;background:#8fd0ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #wrap{position:fixed;inset:0;display:grid;grid-template-rows:1fr auto}
  canvas{width:100%;height:100%;touch-action:none;background:linear-gradient(#8fd0ff,#a7dcff)}
  .hud{display:flex;gap:.6rem;align-items:center;flex-wrap:wrap;padding:.5rem .75rem;background:rgba(255,255,255,.85);border-top:1px solid rgba(0,0,0,.15);backdrop-filter:blur(6px)}
  .btn{border:1px solid rgba(0,0,0,.15);background:#fff;padding:.5rem .75rem;border-radius:.75rem;font-weight:600}
  .pill{padding:.25rem .6rem;border:1px solid rgba(0,0,0,.15);border-radius:999px;background:#fff;font-variant-numeric:tabular-nums}
  .flex-1{flex:1 1 0}
  .dial{position:relative;width:92px;height:92px;border-radius:50%;border:1px solid rgba(0,0,0,.15);background:rgba(255,255,255,.85);display:flex;align-items:center;justify-content:center}
  .dial .nub{position:absolute;width:10px;height:10px;border-radius:50%;background:#111}
  .vslider{position:relative;height:112px;width:38px;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,.85);border:1px solid rgba(0,0,0,.15);border-radius:.75rem}
  .vslider input{transform:rotate(-90deg);width:110px;-webkit-appearance:none;appearance:none;height:26px;background:transparent}
  .vslider input::-webkit-slider-runnable-track{height:8px;background:linear-gradient(90deg,#ddd,#bbb);border-radius:6px}
  .vslider input::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:26px;height:26px;border-radius:50%;background:#fff;border:1px solid rgba(0,0,0,.15);box-shadow:0 1px 2px rgba(0,0,0,.2);margin-top:-9px}
  .vslider label{position:absolute;bottom:4px;font-size:.75rem;opacity:.7}
  .stat{display:flex;gap:.5rem;align-items:center}
  .stat b{min-width:3.2rem;text-align:right}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div class="hud">
    <button class="btn" id="randomWind">Random wind</button>
    <label class="btn" style="display:flex;gap:.5rem;align-items:center">
      <input id="autoTrim" type="checkbox" checked> Auto-trim
    </label>
    <div class="pill stat">Wind <b id="wdir">000°</b><span id="wspd">0.0</span> m/s</div>
    <div class="pill stat">Boat <b id="bhdg">000°</b><span id="bsog">0.00</span> m/s</div>
    <div class="pill stat">Heel <b id="heel">0°</b><span id="stable">stable</span></div>
    <div class="flex-1"></div>

    <!-- Simple, obvious controls: heading dial + two sail angles -->
    <div class="dial" id="hdgDial" title="Heading (drag)">
      <div class="nub" id="hdgNub" style="top:8px;left:50%"></div>
    </div>
    <div class="vslider"><input id="main" type="range" min="-85" max="85" step="1" value="15"><label>Main°</label></div>
    <div class="vslider"><input id="jib"  type="range" min="-85" max="85" step="1" value="20"><label>Jib°</label></div>
    <div class="vslider"><input id="sheet" type="range" min="40" max="100" step="1" value="85"><label>Sheet%</label></div>
  </div>
</div>

<script>
/* ===== math helpers ===== */
const DEG=180/Math.PI, RAD=Math.PI/180, TAU=2*Math.PI;
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const wrapDeg=d=>(d%360+360)%360;
const angDiff=(a,b)=>{let d=wrapDeg(a-b);return d>180?d-360:d;};
const vec=(dir,mag)=>({x:Math.sin(dir*RAD)*mag,y:-Math.cos(dir*RAD)*mag});
const vadd=(a,b)=>({x:a.x+b.x,y:a.y+b.y}); const vscale=(a,s)=>({x:a.x*s,y:a.y*s});
const vmag=a=>Math.hypot(a.x,a.y); const vdir=a=>wrapDeg(Math.atan2(a.x,-a.y)*DEG);

/* ===== canvas ===== */
const cvs=document.getElementById('c'), g=cvs.getContext('2d');
let DPR=1,W=0,H=0; function resize(){DPR=Math.max(1,Math.min(2,devicePixelRatio||1));
  W=cvs.clientWidth;H=cvs.clientHeight;cvs.width=W*DPR;cvs.height=H*DPR;g.setTransform(DPR,0,0,DPR,0,0);} addEventListener('resize',resize,{passive:true});resize();

/* ===== UI & state ===== */
const ui={wdir:document.getElementById('wdir'), wspd:document.getElementById('wspd'),
  bhdg:document.getElementById('bhdg'), bsog:document.getElementById('bsog'),
  heel:document.getElementById('heel'), stable:document.getElementById('stable'),
  main:document.getElementById('main'), jib:document.getElementById('jib'), sheet:document.getElementById('sheet'),
  auto:document.getElementById('autoTrim')};

const dial=document.getElementById('hdgDial'), nub=document.getElementById('hdgNub');
let dragging=false; dial.addEventListener('pointerdown',e=>{dial.setPointerCapture(e.pointerId);dragging=true;updateDial(e);});
dial.addEventListener('pointermove',e=>dragging&&updateDial(e)); dial.addEventListener('pointerup',()=>dragging=false);
function updateDial(e){const r=dial.getBoundingClientRect(); const cx=r.left+r.width/2, cy=r.top+r.height/2;
  const a=Math.atan2(e.clientX-cx, cy-e.clientY)*DEG; boat.targetH=wrapDeg(a);
  const rad=r.width/2-8, vx=Math.sin(a*RAD)*rad, vy=-Math.cos(a*RAD)*rad;
  nub.style.left=(r.width/2+vx)+'px'; nub.style.top=(r.height/2+vy)+'px';}

/* ===== environment & boat ===== */
const env={windDir:0, windSpeed:7, rho:1.22};
function randomWind(){env.windDir=Math.floor(Math.random()*360); env.windSpeed=+(4+Math.random()*9).toFixed(1);}
document.getElementById('randomWind').onclick=randomWind; randomWind();

const boat={
  heading:0, targetH:0, v:{x:0,y:0},
  areaMain:12, areaJib:8, mass:180, keel:6.0, hullDrag:0.45, heel:0,
  offset:{x:0,y:0} // for moving water grid
};

/* ===== sail model aligned to points of sail =====
   - no-sail: |TWA| < 35° -> power fades to 0
   - best drive around beam reach; broad reach ~80% of beam; run ~50%
   - Lift ~ sin(2*alpha); Drag baseline + sin^2(alpha); stall past 70°
*/
function sailForces(apparent, sailAbsDeg, area, sheet){
  const Va=apparent.mag; if(Va<0.15) return {F:{x:0,y:0}, drive:0, side:0, power:0};
  const alpha=(apparent.dir - sailAbsDeg)*RAD; // AoA
  const stall=clamp(1 - Math.max(0,Math.abs(alpha*DEG)-70)/25,0,1);
  let Cl=1.2*Math.sin(2*alpha)*stall;
  let Cd=(0.11+0.9*Math.sin(alpha)**2)*stall;
  // points-of-sail shaping (relative to TRUE wind):
  const TWA=Math.abs(angDiff(env.windDir, boat.heading));
  const posGain = (TWA<35)? (TWA/35) : (TWA<90 ? 1 : (TWA<150 ? 0.85 : 0.55));
  const q=0.5*env.rho*Va*Va*area*(sheet/100)*posGain;

  const ax = Math.sin(apparent.dir*RAD), ay = -Math.cos(apparent.dir*RAD);
  const lx=-ay, ly=ax; // lift ⟂ apparent wind
  const Fx = q*(Cl*lx + Cd*ax), Fy = q*(Cl*ly + Cd*ay);

  // Resolve into boat axes
  const hx=Math.sin(boat.heading*RAD), hy=-Math.cos(boat.heading*RAD);
  const rx=Math.cos(boat.heading*RAD),  ry=Math.sin(boat.heading*RAD);

  const drive=Fx*hx + Fy*hy;
  const side =Fx*rx + Fy*ry;
  return {F:{x:Fx,y:Fy}, drive, side, power:Math.max(0,drive)/(q+1e-9)};
}

/* ===== loop ===== */
let last=performance.now();
function tick(t){
  const dt=Math.min(0.05,(t-last)/1000); last=t;

  // Smooth turn
  const dh=angDiff(boat.targetH, boat.heading); boat.heading=wrapDeg(boat.heading+clamp(dh,-70*dt,70*dt));

  // Auto-trim: set sail angles ~ 1/2 AWA (clamped)
  const trueWind=vec(env.windDir, env.windSpeed);
  const awaVec={x:trueWind.x-boat.v.x,y:trueWind.y-boat.v.y};
  const AWA=wrapDeg(vdir(awaVec)-boat.heading);
  if(ui.auto.checked){
    ui.main.value = clamp(Math.sign(AWA)*Math.min(60, Math.abs(AWA)*0.55), -85, 85).toFixed(0);
    ui.jib.value  = clamp(Math.sign(AWA)*Math.min(70, Math.abs(AWA)*0.62), -85, 85).toFixed(0);
  }

  // Apparent wind
  const Va={x:trueWind.x-boat.v.x,y:trueWind.y-boat.v.y};
  const apparent={mag:vmag(Va), dir:vdir(Va)};

  const mainAbs=boat.heading+parseFloat(ui.main.value);
  const jibAbs =boat.heading+parseFloat(ui.jib.value);
  const sheet=parseFloat(ui.sheet.value);

  const fM=sailForces(apparent, mainAbs, boat.areaMain, sheet);
  const fJ=sailForces(apparent,  jibAbs,  boat.areaJib,  sheet*0.9);

  // Sum & decompose
  const F=vadd(fM.F,fJ.F);
  const hx=Math.sin(boat.heading*RAD), hy=-Math.cos(boat.heading*RAD);
  const rx=Math.cos(boat.heading*RAD),  ry=Math.sin(boat.heading*RAD);
  let drive=fM.drive+fJ.drive, side=fM.side+fJ.side;

  // Keel resists side force; some becomes leeway + heel
  side -= side/(1+boat.keel);
  const leewayAccel=(side*0.08)/boat.mass;
  const forwardAccel=(drive - boat.hullDrag*vmag(boat.v)**2)/boat.mass;

  // Update velocity (world)
  const axw=hx*forwardAccel + rx*leewayAccel;
  const ayw=hy*forwardAccel + ry*leewayAccel;
  boat.v.x+=axw*dt; boat.v.y+=ayw*dt;

  // Heel & stability
  boat.heel=clamp(Math.abs(side)*0.0038,0,55);
  const stable=boat.heel<42;
  const speed=vmag(boat.v);

  // Scroll water grid to convey motion
  boat.offset.x=(boat.offset.x - boat.v.x*dt*20);
  boat.offset.y=(boat.offset.y - boat.v.y*dt*20);

  draw(trueWind, apparent, fM, fJ, F, stable, speed, AWA);

  // HUD
  ui.wdir.textContent=String(wrapDeg(env.windDir)).padStart(3,'0')+'°';
  ui.wspd.textContent=env.windSpeed.toFixed(1);
  ui.bhdg.textContent=String(wrapDeg(boat.heading)).padStart(3,'0')+'°';
  ui.bsog.textContent=speed.toFixed(2);
  ui.heel.textContent=Math.round(boat.heel)+'°';
  ui.stable.textContent=stable?'stable':'overpowered';

  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* ===== drawing ===== */
function draw(trueWind, apparent, fM, fJ, F, stable, speed, AWA){
  g.clearRect(0,0,W,H);

  // Moving water grid
  g.save();
  g.translate(boat.offset.x%40, boat.offset.y%40);
  g.globalAlpha=.25; g.fillStyle='#ffffff';
  for(let y=-40;y<H+40;y+=40) g.fillRect(0,y,W,1);
  g.globalAlpha=.15; g.fillStyle='#e6f5ff';
  for(let x=-40;x<W+40;x+=40) g.fillRect(x,0,1,H);
  g.restore();

  const cx=W/2, cy=H/2;

  // Points-of-sail wheel (reference)
  g.save();
  g.translate(cx,cy);
  g.rotate(boat.heading*RAD);
  // no-sail sector ±35°
  g.globalAlpha=.15; g.fillStyle='#ff6aa0';
  g.beginPath(); g.moveTo(0,0); g.arc(0,0,110,-35*RAD,35*RAD,false); g.closePath(); g.fill();
  // beam & broad tick marks
  g.globalAlpha=.25; g.strokeStyle='#222'; g.lineWidth=2;
  const ticks=[-150,-135,-120,-90,-60,-45,-35,35,45,60,90,120,135,150];
  ticks.forEach(a=>{g.beginPath(); g.rotate(a*RAD); g.moveTo(100,0); g.lineTo(110,0); g.stroke(); g.rotate(-a*RAD);});
  g.globalAlpha=1;

  // Boat hull + mast (centered, very simple)
  drawBoat();

  // Sails as lines (obvious placement)
  drawBoom(parseFloat(ui.main.value), 60, '#111');
  drawBoom(parseFloat(ui.jib.value),  40, '#333');

  g.restore();

  // WIND at top & AWA near boat
  drawArrow(W/2, 28, env.windDir, 46, '#005bbb', 'WIND');
  drawArrow(cx, cy-80, apparent.dir, 36, '#333', 'AWA');

  // Force vectors (main, jib, resultant)
  drawVector(cx,cy, fM.F, 0.02, '#44aa44', 'Main F');
  drawVector(cx,cy, fJ.F, 0.02, '#2a7fea', 'Jib F');
  drawVector(cx,cy, F,     0.02, '#000',   'Resultant');

  // Velocity vector
  drawVector(cx,cy, boat.v, 10, stable? '#0a0':'#c00', 'Velocity');

  // Speedometer (bottom-right)
  drawGauge(W-130, H-130, speed, AWA, stable);

  function drawBoat(){
    g.fillStyle='#222'; g.strokeStyle='rgba(0,0,0,.25)'; g.lineWidth=1.5;
    g.beginPath(); g.moveTo(0,-25); g.quadraticCurveTo(10,10,0,25); g.quadraticCurveTo(-10,10,0,-25); g.closePath(); g.fill(); g.stroke();
    // mast
    g.beginPath(); g.moveTo(0,-5); g.lineTo(0,-42); g.stroke();
    // heading tick
    g.beginPath(); g.moveTo(0,-70); g.lineTo(0,-92); g.stroke();
  }
  function drawBoom(angleRel,len,color){
    g.save(); g.rotate(angleRel*RAD);
    g.strokeStyle=color; g.lineWidth=3;
    g.beginPath(); g.moveTo(0,-5); g.lineTo(len,-5); g.stroke(); g.restore();
  }
  function drawArrow(x,y,dir,len,color,label){
    const a=dir*RAD, ex=x+Math.sin(a)*len, ey=y-Math.cos(a)*len;
    g.strokeStyle=color; g.lineWidth=3; g.lineCap='round';
    g.beginPath(); g.moveTo(x,y); g.lineTo(ex,ey); g.stroke();
    g.beginPath(); g.moveTo(ex,ey);
    g.lineTo(ex+Math.sin((dir+150)*RAD)*12, ey-Math.cos((dir+150)*RAD)*12);
    g.lineTo(ex+Math.sin((dir-150)*RAD)*12, ey-Math.cos((dir-150)*RAD)*12); g.closePath();
    g.fillStyle=color; g.fill();
    g.font='12px system-ui,-apple-system,sans-serif'; g.globalAlpha=.6; g.fillStyle='#000';
    if(label) g.fillText(label, x-18, y-10); g.globalAlpha=1;
  }
  function drawVector(x,y,v,scale,color,label){
    const sx=v.x*scale, sy=v.y*scale, ex=x+sx, ey=y+sy;
    g.strokeStyle=color; g.lineWidth=3; g.beginPath(); g.moveTo(x,y); g.lineTo(ex,ey); g.stroke();
    // tip
    const dir=vdir(v); drawArrow(ex,ey,dir,0,color);
    g.font='12px system-ui,-apple-system,sans-serif'; g.globalAlpha=.6; g.fillStyle='#000';
    if(label) g.fillText(label, ex+6, ey+2); g.globalAlpha=1;
  }
  function drawGauge(x,y,speed,AWA,stable){
    const r=54; g.save(); g.translate(x,y);
    g.fillStyle='rgba(255,255,255,.9)'; g.strokeStyle='rgba(0,0,0,.15)';
    g.beginPath(); g.arc(0,0,r+16,0,TAU); g.fill(); g.stroke();
    // ring
    g.lineWidth=6; g.strokeStyle=stable?'#0a0':'#c00';
    g.beginPath(); g.arc(0,0,r, -Math.PI*0.75, -Math.PI*0.75 + Math.min(1,speed/5)*Math.PI*1.5); g.stroke();
    // text
    g.fillStyle='#000'; g.font='12px system-ui,-apple-system,sans-serif';
    g.fillText('SOG (m/s): '+speed.toFixed(2), -44, 6);
    g.fillText('AWA: '+Math.round(AWA)+'°', -36, 22);
    // VMG upwind/downwind
    const twa=Math.abs(angDiff(env.windDir, boat.heading));
    const vmg = speed*Math.cos(twa*RAD);
    g.fillText('VMG: '+vmg.toFixed(2), -34, 38);
    g.fillText('Heel: '+Math.round(boat.heel)+'°', -36, 54);
    g.restore();
  }
}
</script>
</body>
</html>
